
**Project: Time-Based Lathe Simulator**

**Overview:**

This project is a time-based lathe simulator that visualizes G-code programs. It provides a graphical representation of a workpiece, a tool, and the toolpath generated by executing G-code commands. The simulator features a user interface built with ImGui, allowing users to load G-code files, control the simulation (start, pause, skip, reset), adjust the view (pan, zoom), and inspect the machine state.

**Code Structure:**

The project consists of the following files:

*   **`Common.h`:** Defines common constants, macros, and data structures used throughout the project, including the `GCommand` struct and the `gCodeDocs` map.
*   **`Common.cpp`:** Implements functions and variables declared in `Common.h`.
*   **`GCodeParser.h`:** Defines the `GCodeParser` class, responsible for parsing G-code files and loading them into a command queue.
*   **`GCodeParser.cpp`:** Implements the `GCodeParser` class.
*   **`CommandQueue.h`:** Defines the `CommandQueue` class, which manages a queue of G-code commands and handles thread synchronization for accessing the queue.
*   **`CommandQueue.cpp`:** Implements the `CommandQueue` class.
*   **`MachineState.h`:** Defines the `MachineState` struct, which holds the current state of the simulated lathe (e.g., position, feed rate, spindle speed).
*   **`Tool.h`:** Defines the `Tool` struct, representing a cutting tool with properties like tool number, diameter, type, and color.
*   **`ViewState.h`:** Defines the `ViewState` struct, managing the view parameters for the simulation (e.g., zoom, pan).
*   **`SimulationEngine.h`:** Defines the `SimulationEngine` class, the core of the simulator. It executes G-code commands, updates the machine state, and manages the simulation thread.
*   **`SimulationEngine.cpp`:** Implements the `SimulationEngine` class.
*   **`Renderer.h`:** Defines the `Renderer` class, responsible for rendering the simulation scene using OpenGL.
*   **`Renderer.cpp`:** Implements the `Renderer` class.
*   **`UIHandler.h`:** Defines the `UIHandler` class, which manages the user interface using ImGui.
*   **`UIHandler.cpp`:** Implements the `UIHandler` class.
*   **`main.cpp`:** Contains the `main` function, the entry point of the application. It initializes GLFW, GLAD, ImGui, creates the main components (SimulationEngine, Renderer, UIHandler), and runs the main event loop.

**File Details:**

**1. Common.h/Common.cpp:**

*   **Purpose:** Defines common constants, macros, and data structures.
*   **Key Elements:**
    *   `WINDOW_WIDTH`, `WINDOW_HEIGHT`: Window dimensions.
    *   `Z_NEAR`, `Z_FAR`: Clipping planes for orthographic projection.
    *   `CHECK_ERROR` macro: Basic error checking.
    *   `GCommand` struct: Represents a single G-code command with its type, code, parameters (X, Z, I, K, F, S, T), and flags indicating the presence of each parameter.
    *   `gCodeDocs` map: Stores G-code documentation (code -> description).

**2. GCodeParser.h/GCodeParser.cpp:**

*   **Purpose:** Parses G-code files and loads them into a `CommandQueue`.
*   **Key Elements:**
    *   `parseAndQueueCommand()`: Parses a single line of G-code, extracts the command type and parameters, creates a `GCommand` object, and adds it to the `CommandQueue`.
    *   `loadGCode()`: Loads a G-code program from a file or uses the default program. It clears the existing program, resets the machine state, and parses each line using `parseAndQueueCommand()`.
    *   `getGCodeProgram()`: Returns the loaded G-code program as a vector of strings.
    *   `getCurrentGCodeFilename()`: Returns the name of the currently loaded G-code file.
    *   `defaultGCodeProgram`: A string containing a default G-code program for testing.

**3. CommandQueue.h/CommandQueue.cpp:**

*   **Purpose:** Manages a queue of `GCommand` objects and provides thread-safe access to the queue.
*   **Key Elements:**
    *   `queue`: A `std::queue` to store `GCommand` objects.
    *   `mtx`: A `std::mutex` to protect access to the queue from multiple threads.
    *   `cv`: A `std::condition_variable` to synchronize access to the queue.
    *   `addCommand()`: Adds a command to the queue and notifies any waiting threads.
    *   `getNextCommand()`: Retrieves and removes the next command from the queue, waiting if the queue is empty.
    *   `isEmpty()`: Checks if the queue is empty.
    *   `clear()`: Clears the queue.
    *   `signal()`: Notifies waiting threads that the queue might have changed.
    *   `getQueueSize()`: Returns the current size of the queue.

**4. MachineState.h:**

*   **Purpose:** Defines the `MachineState` struct to hold the current state of the simulated lathe.
*   **Key Elements:**
    *   `position`: Current tool position (X, Z).
    *   `targetPosition`: Target position for the current move.
    *   `isMoving`: Flag indicating if the tool is currently moving.
    *   `isSimulationRunning`: Flag indicating if the simulation is running.
    *   `feedRate`: Current feed rate.
    *   `rapidRate`: Rapid movement feed rate.
    *   `absolutePositioning`: Flag for absolute/incremental mode.
    *   `moveStartTime`: Time point when the current move started.
    *   `moveDuration`: Calculated duration of the current move.
    *   `currentCommandLine`: Line number of the currently executing G-code command.
    *   `simulationStartTime`: Time point when the simulation started.
    *   `lastGCode`: The last executed G-code.
    *   `spindleSpeedRPM`: Simulated spindle speed.
    *   `workOffset`: Work offset (X, Z).
    *   `acceleration`: Acceleration.
    *   `deceleration`: Deceleration.
    *   `currentToolNumber`: Currently active tool number.
    *   `workpieceLength`: Initial workpiece length.
    *   `workpieceDiameter`: Initial workpiece diameter.

**5. Tool.h:**

*   **Purpose:** Defines the `Tool` struct to represent a cutting tool.
*   **Key Elements:**
    *   `toolNumber`: Tool identifier.
    *   `toolDiameter`: Tool diameter.
    *   `toolType`: Description of the tool type (e.g., "Roughing", "Finishing").
    *   `color`: Color used to visualize the tool's path.

**6. ViewState.h:**

*   **Purpose:** Defines the `ViewState` struct to manage view parameters.
*   **Key Elements:**
    *   `scale`: Overall zoom scale.
    *   `offset`: View offset (for panning).
    *   `scaleXY`: Independent scale for X and Y.
    *   `lastMousePos`: Last mouse position (for panning calculations).
    *   `isDragging`: Flag indicating if panning is active.
    *   `zoomSpeed`: Zoom speed factor.
    *   `panSpeed`: Panning speed factor.

**7. SimulationEngine.h/SimulationEngine.cpp:**

*   **Purpose:** The core of the simulation. Executes G-code commands, updates the machine state, and manages the simulation thread.
*   **Key Elements:**
    *   `State` enum: Defines the possible states of the simulation (Idle, Running, Paused, Stopped).
    *   `machine`: A shared pointer to the `MachineState`.
    *   `commandQueue`: A shared pointer to the `CommandQueue`.
    *   `simulationThread`: The thread that executes G-code commands.
    *   `mtx`: A mutex for thread synchronization when accessing shared data.
    *   `cv`: A condition variable for thread synchronization.
    *   `shouldExit`: A flag to signal the simulation thread to stop.
    *   `currentState`: The current state of the simulation.
    *   `skipLine`: A flag to skip the current G-code line.
    *   `currentLine`: The current line number being executed.
    *   `currentRunTimeTotal`: The total simulation time.
    *   `lastTimeRecord`: The last recorded time point for time calculations.
    *   `toolPath`: A vector storing the toolpath points.
    *   `positionHistory`: A deque storing the recent history of tool positions for the graph.
    *   `tools`: A map of available tools.
    *   `currentTool`: The currently active tool.
    *   `executeCommand()`: Executes a single G-code command, updating the machine state accordingly.
    *   `updateMovement()`: Updates the tool's position based on the elapsed time and target position, handling acceleration and deceleration.
    *   `startSimulationThread()`: Starts the simulation thread.
    *   `stopSimulationThread()`: Stops the simulation thread.
    *   `setState()`: Changes the simulation state (e.g., from Paused to Running).
    *   `setSkipLine()`: Sets the `skipLine` flag.
    *   `resetSimulation()`: Resets the simulation to its initial state.
    *   Accessor methods: `getCurrentLine()`, `getIsPaused()`, `getIsRunning()`, `getCurrentRunTimeTotal()`, `getToolPath()`, `getPositionHistory()`, `getCurrentTool()`, `setCurrentTool()`.

**8. Renderer.h/Renderer.cpp:**

*   **Purpose:** Renders the simulation scene using OpenGL.
*   **Key Elements:**
    *   `machine`: A shared pointer to the `MachineState`.
    *   `view`: A shared pointer to the `ViewState`.
    *   OpenGL objects: `workpieceVAO`, `workpieceVBO`, `toolPathVAO`, `toolPathVBO`, `shaderProgram`.
    *   Shader uniform locations: `modelLoc`, `viewLoc`, `projectionLoc`, `colorLoc`.
    *   Vertex and fragment shader source code.
    *   `initialize()`: Initializes OpenGL objects and shaders.
    *   `render()`: Renders the scene (workpiece, toolpath, tool, work origin).
    *   `setupShaders()`: Compiles and links the shader programs.
    *   `initializeWorkpiece()`: Initializes the workpiece vertices.
    *   `renderWorkpiece()`: Renders the workpiece.
    *   `renderToolPath()`: Renders the toolpath.
    *   `renderTool()`: Renders the tool as a point.
    *   `renderWorkOrigin()`: Renders the work origin as a point.
    *   `renderDashedLine()`: Renders a dashed line for rapid moves (G00).

**9. UIHandler.h/UIHandler.cpp:**

*   **Purpose:** Manages the user interface using ImGui.
*   **Key Elements:**
    *   `window`: A pointer to the GLFW window.
    *   `machine`: A shared pointer to the `MachineState`.
    *   `view`: A shared pointer to the `ViewState`.
    *   `gCodeParser`: A shared pointer to the `GCodeParser`.
    *   `simulationEngine`: A shared pointer to the `SimulationEngine`.
    *   UI variables: `graphScaleX`, `graphScaleZ`, `graphOffset`, `GRAPH_HISTORY_SIZE`.
    *   `renderGUI()`: Renders the main GUI using ImGui, including menus, controls, and the position graph.
    *   `handleInput()`: Handles keyboard and mouse input for panning and zooming.
    *   `handleScroll()`: Handles mouse scroll wheel input for zooming.
    *   `renderPositionGraph()`: Renders the graph of the tool's position history.
    *   `setupImGuiStyle()`: Sets up the ImGui style (colors, spacing, etc.).

**10. main.cpp:**

*   **Purpose:** The entry point of the application.
*   **Key Elements:**
    *   `main()` function:
        *   Initializes GLFW, GLAD, and ImGui.
        *   Creates shared pointers for `MachineState`, `ViewState`, `CommandQueue`, and `GCodeParser`.
        *   Creates instances of `SimulationEngine`, `Renderer`, and `UIHandler`.
        *   Sets up GLFW callbacks (e.g., scroll callback).
        *   Loads the default G-code.
        *   Starts the simulation thread.
        *   Enters the main event loop:
            *   Processes events (keyboard, mouse, window events).
            *   Starts a new ImGui frame.
            *   Calls `simulationEngine->updateMovement()`.
            *   Calls `uiHandler.handleInput()`.
            *   Calls `renderer.render()`.
            *   Calls `uiHandler.renderGUI()`.
            *   Renders the ImGui draw data.
            *   Swaps the front and back buffers.
        *   Cleans up resources (stops the simulation thread, shuts down ImGui, destroys the window, terminates GLFW).

**Further Development:**

Here are some suggestions for further development:

**1. Implement Missing G-codes and M-codes:**

*   Add the logic for all the G-codes and M-codes that are currently marked as "Not Implemented" or "Placeholder" in `SimulationEngine::executeCommand()`. Refer to the `gCodeDocs` map and G-code documentation for the specific behavior of each code.

**2. Enhanced G-code Support:**

*   **Unit Conversion:** Implement proper handling of `G20` (inches) and `G21` (millimeters) to switch between units within the simulation. This will require modifying calculations involving distances, feed rates, and other relevant parameters.
*   **Subprogram Calls:** Add support for `M98` (subprogram call) and `M99` (subprogram return). You might need to implement a stack to keep track of the return addresses.
*   **Canned Cycles:** Implement the logic for canned cycles (G70-G89), which are more complex operations often used in turning and milling.
*   **Tool Radius Compensation:** Implement `G40`, `G41`, and `G42` for tool radius compensation. This will involve offsetting the toolpath based on the tool's radius.

**3. Improved Simulation Logic:**

*   **Collision Detection:** Add collision detection between the tool and the workpiece. This can be done by checking if the tool's path intersects with the workpiece geometry.
*   **Material Removal:** Implement a more realistic simulation of material removal. This could involve dynamically updating the workpiece geometry as the tool moves. You might consider using a 2D grid or a voxel-based approach to represent the workpiece.
*   **Spindle Speed Control:** Implement more accurate simulation of spindle speed control (G96, G97) and its effect on the machining process.
*   **Feed Rate Control:** Implement more accurate simulation of feed rate control (G98, G99) and its effect on the machining process.

**4. UI Improvements:**

*   **File Dialog:** Replace the placeholder comment in the "Open G-Code" menu item with a proper file dialog to allow users to select G-code files from their file system.
*   **Error Handling:** Display error messages to the user in the UI when errors occur (e.g., invalid G-code, file not found).
*   **Status Window:** Add more information to the "Simulator Status" window, such as:
    *   Current tool information (number, diameter, type).
    *   Error messages.
    *   Warnings or informational messages.
*   **G-code Highlighting:** Highlight the currently executing line in the G-code program window more prominently. Consider using different colors to indicate different types of G-code commands.
*   **Customizable Settings:** Allow users to customize more settings, such as:
    *   Default units (inches/millimeters).
    *   Default acceleration/deceleration values.
    *   Colors for different UI elements.
*   **Zoom to Fit:** Add a "Zoom to Fit" feature that automatically adjusts the zoom level to fit the entire workpiece and toolpath within the view.
*   **3D View:** Consider adding a 3D view of the simulation to provide a more realistic visualization.

**5. Performance Optimization:**

*   **Profiling:** Use a profiler to identify performance bottlenecks in your code.
*   **OpenGL Optimization:** Optimize the rendering code in `Renderer.cpp` to improve performance. Consider using more efficient rendering techniques if you add more complex geometry (e.g., material removal).
*   **Multithreading:** Explore ways to use multithreading to improve performance, especially for computationally intensive tasks like collision detection and material removal.

**6. Code Structure and Maintainability:**

*   **State Pattern:** Consider implementing the State pattern (as suggested in a previous response) to manage the different states of the `SimulationEngine` more cleanly.
*   **Modularization:** Break down large classes into smaller, more manageable classes with specific responsibilities.
*   **Comments and Documentation:** Add more detailed comments to your code to explain the logic and make it easier to understand. Generate documentation using a tool like Doxygen.

**7. Testing:**

*   **Unit Tests:** Write unit tests to verify the correctness of individual components (e.g., `GCodeParser`, `CommandQueue`, `SimulationEngine`).
*   **Integration Tests:** Write integration tests to ensure that the different components of the simulator work together correctly.
*   **Regression Tests:** Create a suite of regression tests to prevent the introduction of new bugs when making changes to the code.

**8. Advanced Features:**

*   **Tool Wear:** Simulate tool wear and its effect on the machining process.
*   **Cutting Forces:** Calculate and visualize cutting forces.
*   **Temperature Simulation:** Simulate the temperature of the workpiece and tool during machining.
*   **Sound Effects:** Add sound effects to make the simulation more immersive.

By implementing these improvements, you can create a more robust, feature-rich, and user-friendly lathe simulator. Remember to prioritize the features that are most important to you and your users, and to break down the development process into smaller, manageable tasks.
